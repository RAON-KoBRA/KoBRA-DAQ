#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <time.h>
#include <math.h>
#include <string.h>
#include <unistd.h>
#include <memory.h>
#include <ctype.h>

#include <cvt_board_commons.h>
#include <cvt_common_defs.h>

#include <cvt_V792.h>

#include "midas.h"
#include "mfe_silicon.h"
#include "odb_trigger.h"
#include "detector_conf.h"

static cvt_V792_data F3_SILICON_type;


INT f3_silicon_init(int32_t BHandle)
{
	int32_t addr;
	UINT16 firmware_rev, Bit_set_1_reg, Bit_set_2_reg, reg_value;

	printf("\n========================== Initializing F3 SILICON ADC...\n");
	printf("V785N initialization...");
	if(!cvt_V792_open(&F3_SILICON_type, F3_SILICON_ADDR, BHandle, CVT_V785_TYPE_N))
	{
		printf("\n Error executing cvt_F3_SILICON_type_open \n");
		return FE_ERR_HW;
	}

	//=================================data clear
	 if (!cvt_V792_data_clear( &F3_SILICON_type))
	 {
		printf( "\nError executing V785N_data_clear \n");
		return FE_ERR_HW;
	 }
	 printf("Done\n");

	 //==================================firmware version
	 addr=(F3_SILICON_ADDR<<16)|0x1000;
	 CAENVME_ReadCycle(BHandle, addr, &firmware_rev, cvA32_S_DATA, cvD16);

	 printf("Firmware Rev. : %x\n", firmware_rev);

	 cvt_V792_data_clear(&F3_SILICON_type);

	return SUCCESS;
}

INT f3_silicon_exit(int32_t BHandle)
{
	cvt_V792_software_reset(&F3_SILICON_type);
	cvt_V792_close(&F3_SILICON_type);
	return SUCCESS;
}

INT f3_silicon_begin(int32_t BHandle, INT run_number, char *error, TRIGGER_SETTINGS *ts)
{
	uint32_t addr;
	uint16_t reg_value, c_reg_value, get_reg_value;

	//=======================set operation mode====================//--->see V785N manual page 53-55
	addr=(F3_SILICON_ADDR<<16)|0x1032; //==================set bit
	reg_value=0x4980;
	CAENVME_WriteCycle(BHandle, addr, &reg_value, cvA32_S_DATA, cvD16);

	addr=(F3_SILICON_ADDR<<16)|0x1034; //==================clear bit
	c_reg_value=(~reg_value)&0x7fff;
	CAENVME_WriteCycle(BHandle, addr, &c_reg_value, cvA32_S_DATA, cvD16);

	//===============================set control register=============================//--->see V785N manual page 48-49, 66
	addr=(F3_SILICON_ADDR<<16)|0x1010;
	reg_value=0x00;
	CAENVME_WriteCycle(BHandle, addr, &reg_value, cvA32_S_DATA, cvD16);

	//==============================crate select register=============================//--->see V785N manual page 57
	addr=(F3_SILICON_ADDR<<16)|0x103c;
	reg_value=0xd;
	CAENVME_WriteCycle(BHandle, addr, &reg_value, cvA32_S_DATA, cvD16);

	//================================set threshold============================
	addr=(F3_SILICON_ADDR<<16)|0x1080;  //ch0
	reg_value=0x001;
	CAENVME_WriteCycle(BHandle, addr, &reg_value, cvA32_S_DATA, cvD16);

	return SUCCESS;

}


INT f3_silicon_end(int32_t BHandle, INT run_number, char *error)
{
	cvt_V792_data_clear(&F3_SILICON_type);
	return SUCCESS;
}


INT f3_silicon_check_fifo(int32_t BHandle)
{
	uint32_t addr;
	uint16_t status_reg1;
	int status_reg_chk;

	addr=(F3_SILICON_ADDR<<16)|0x100E;
	status_reg1=CAENVME_ReadCycle(BHandle, addr, &status_reg1, cvA32_S_DATA, cvD16);
	status_reg_chk=status_reg1&0x0007;

	printf("==%x\n", status_reg1);

//	uint32_t q_length;
//	cvt_V792_read_data(&F3_SILICON_type);
//	q_length=cvt_V792_get_queue_length(&F3_SILICON_type);
//

	//cvt_V792_get_queue_length(&F3_SILICON_type);
	return SUCCESS;
}

INT f3_silicon_read_fifo(int32_t BHandle, void *buff_tmp, int size)
{
	int count;
	uint32_t addr;
	uint32_t check;
	cvt_V792_read_MEB(&F3_SILICON_type, buff_tmp, &size);

	addr = (F3_SILICON_ADDR<<16)|0x0000;
	//CAENVME_BLTReadCycle(BHandle, addr, (char*)buff_tmp, size, cvA32_S_MBLT, cvD64, &count);

	//count=cvt_V792_read_data(&F3_SILICON_type);

	//CAENVME_ReadCycle(BHandle, addr, &check, cvA32_S_DATA, cvD32);
	printf("%x\n",check);

	return count;
}


INT f3_silicon_read_event(int32_t BHandle, const char *bank_name, char *pevent, INT off, uint32_t *buff, int buff_size, uint32_t *pdata)
{
	int count=f3_silicon_read_fifo(BHandle, buff, buff_size);
	printf("==============================%d\n", count);

#if 0
bk_create(pevent, bank_name, TID_DWORD, (void**)&pdata);

	for(i=0; i<count/4; i++)
	{
		uint32_t data=buff[i];
		switch(data&CVT_V1190_DATA_TYPE_MSK)
		{
			case CVT_V1190_GLOBAL_HEADER:
				{
					UINT32 event_count= CVT_V1190_GET_GLB_HDR_EVENT_COUNT(data);
					UINT32 geo= CVT_V1190_GET_GLB_HDR_GEO(data);

					*pdata++=event_count;
					printf("f2_Global_header; event_count:%d\n", event_count);
				} break;

			case CVT_V1190_TDC_MEASURE:
					{
						UINT32 channel= CVT_V1290_GET_TDC_MSR_CHANNEL(data);
						UINT32 measure= CVT_V1290_GET_TDC_HDR_MEASURE(data);

						*pdata++=channel;
						*pdata++=measure;
						printf("f2_TDC measurement; channel:%d, measurement:%05f\n", channel, measure*0.025);
					} break;

			case CVT_V1190_GLOBAL_TRIGGER_TIME:
				{
					time_stamp1=CVT_V1190_GET_GLB_TRG_TIME_TAG(data);
					if(f2_f_time>time_stamp1){time_stamp2+=0x8000000;}
					f2_f_time=time_stamp1;

					*pdata++=time_stamp2;
					*pdata++=time_stamp1;
					printf("f2_Global_time_tag:%d, u_time:%11f\n", time_stamp1, (time_stamp2|time_stamp1)*800e-9);
				} break;


			default:
				{
			//	printf("unknown data packets\n");
				} break;
		}
	}

	bk_close(pevent, pdata);


return bk_size(pevent);
#endif
return SUCCESS;
}











